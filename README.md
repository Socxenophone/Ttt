DirectChatLink SystemThis repository contains the components for a minimalist real-time chat system designed to facilitate direct communication between clients and customer service agents. It comprises a central relay server and a basic agent monitoring/interaction tool.PurposeThe DirectChatLink system is engineered to serve as a simple, dedicated channel for routing chat messages directly from a client interface to a human agent interface, and vice-versa. Its design prioritizes straightforward message relay over complex features, making it suitable for scenarios where direct human interaction is the primary requirement.ArchitectureThe system is structured into three distinct, interconnected components:Client Frontend: The user-facing interface (typically a web application) where the client initiates and participates in the chat. This component connects to the ChatRelay Server via SocketIO.ChatRelay Server (server.py): This Python application acts as a neutral middleman. It receives messages from clients and forwards them to connected agents, and receives messages from agents to forward back to their respective clients. It performs no AI processing or content interpretation.Agent Dashboard (dashboard.py or separate application): The interface used by customer service agents. It connects to the ChatRelay Server, receives incoming client messages (potentially with client identifiers), and allows agents to send responses back to specific clients. The provided dashboard.py is a basic terminal-based example; a production dashboard would likely be a more sophisticated web application.Architectural Rationale:This decoupled architecture is deliberately chosen for its simplicity and clarity, aligning with the limited use case of direct client-agent routing.Separation of Concerns: The server is solely responsible for message routing, keeping its logic minimal and focused. Client and agent interfaces handle presentation and user interaction independently.Maintainability: Changes to the client frontend or agent dashboard can be made without impacting the core server logic, provided the SocketIO event structure is maintained.Scalability (Basic): While the current server is single-process, the clear separation allows for potential scaling of the server component independently of the frontends/dashboards if message volume increases significantly (though a more robust message queue might be needed for high loads).Security: Isolating the routing logic in the server allows for centralized control over connections and message flow, although robust authentication/authorization (especially for agents) is critical and must be implemented.This structure is intentionally simple and efficient for its specific task, avoiding the overhead and complexity of systems designed for broader chat functionalities or AI integration.Limited Use CaseIt is important to note that the DirectChatLink system is designed specifically for facilitating direct, human-to-human chat communication mediated by a simple relay. It is not intended as:A general-purpose chat platform with features like group chats, persistent message history (beyond the current session), or file sharing.A system for integrating conversational AI or automated responses (as the AI component was explicitly removed).A system requiring complex message processing or analysis within the server component.Its utility lies in providing a direct pipeline between a client needing support and an agent providing it.SetupTo set up and run the components:Clone the Repository: (Assuming both server.py and dashboard.py are in this repository)git clone <repository_url>
cd <repository_name>
Install Dependencies: Ensure you have Python installed. Install the required libraries for both components:pip install Flask Flask-SocketIO eventlet
(Note: dashboard.py uses the socketio client, which is part of the python-socketio package installed by Flask-SocketIO).Configuration: Both server.py and dashboard.py rely on environment variables for configuration.For server.py:SERVER_HOST: Host IP address for the server (e.g., 0.0.0.0). Defaults to 0.0.0.0.SERVER_PORT: Port number for the server (e.g., 5000). Defaults to 5000.ALLOWED_ORIGINS: Comma-separated allowed origins for CORS. CRITICAL: Restrict this in production. Defaults to *.LOG_FILE: Path for server logs. Defaults to middleman.log.LOG_LEVEL: Server logging level (DEBUG, INFO, etc.). Defaults to INFO.For dashboard.py:SERVER_ADDRESS: The full URL of the running ChatRelay Server (e.g., http://localhost:5000). Defaults to http://localhost:5000.Set these variables in your environment before running the respective scripts.UsageStart the Server: In a terminal, navigate to the repository directory and run:python server.py
The server will begin listening on the configured host and port.Run the Agent Dashboard: In a separate terminal, navigate to the repository directory and run:python dashboard.py
The dashboard will attempt to connect to the server. Once connected, you can see incoming client messages and type responses. Type exit or quit to disconnect the dashboard.Connect Client Frontend: Develop or use a client frontend (e.g., an HTML page with JavaScript) that connects to the ChatRelay Server's address using a SocketIO client library. This frontend should emit client_message events and listen for message_to_client events.SocketIO EventsThe system utilizes the following SocketIO events:Server (server.py) Handlers:connect(sid, environ): Handles new connections.disconnect(sid): Handles disconnections.client_message(sid, data): Receives messages from clients.agent_message(sid, data): Receives messages from agents.agent_connect(sid, data): Handles agent identification (authentication needed in production).Server (server.py) Emitters:message_to_agent(data, room=agent_sid): Sends client messages to agents.message_to_client(data, room=client_sid): Sends agent messages to clients.system_message_to_agent(data, room=agent_sid): Sends system notifications to agents.Agent Dashboard (dashboard.py) Handlers:connect(): Handles successful connection to the server.disconnect(): Handles disconnection from the server.message_to_agent(data): Receives messages from clients (via the server).system_message_to_agent(data): Receives system notifications from the server.Agent Dashboard (dashboard.py) Emitters:agent_connect(data): Emitted upon connection to identify as an agent (authentication data should be included in production).agent_message(data): Sends messages to clients (via the server).Client Frontend Handlers:connect(): Handles successful connection to the server.disconnect(): Handles disconnection from the server.message_to_client(data): Receives messages from agents (via the server).Client Frontend Emitters:client_message(data): Sends messages to the server.Production Deployment NotesAs previously stated, running the Python scripts directly is suitable for development. For production, employ robust practices:WSGI Server: Use Gunicorn or uWSGI with eventlet workers for server.py.Reverse Proxy: Implement Nginx or Caddy for SSL, load balancing, and potentially serving the client frontend static files.Authentication & Authorization: Implement a secure mechanism for agents to authenticate with the server upon agent_connect. The server must verify that an agent is authorized to message a specific client.Session Management: Develop a more sophisticated system for managing client-agent assignments, handling agent availability, client queues, and conversation state persistence.Error Monitoring: Utilize the configured logging and potentially integrate with external monitoring systems.Environment Variables: Manage environment variables securely in your deployment environment.Contributing(Placeholder for contribution guidelines)License(Placeholder for license information)
